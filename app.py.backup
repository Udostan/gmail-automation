# Required imports
import streamlit as st
import os
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from email.mime.text import MIMEText
import base64
import requests
from urllib.parse import urlparse, parse_qs
from google.auth.transport.requests import Request
from supabase import create_client
from datetime import datetime, timezone
import time
import json

# Page configuration must be the first Streamlit command
st.set_page_config(
    page_title="Gmail AI Assistant",
    page_icon="✉️",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Disable OAuthlib's HTTPS verification when running locally
os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'

# Define OAuth scopes consistently
GMAIL_SCOPES = [
    'https://www.googleapis.com/auth/gmail.send',
    'https://www.googleapis.com/auth/gmail.compose',
    'https://www.googleapis.com/auth/gmail.modify',
    'https://mail.google.com/'
]

# Initialize session state
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False
if 'token' not in st.session_state:
    st.session_state.token = None
if 'ai_response' not in st.session_state:
    st.session_state.ai_response = ""
if 'message_input' not in st.session_state:
    st.session_state.message_input = ""
if 'oauth_error' not in st.session_state:
    st.session_state.oauth_error = None

# Groq API configuration
GROQ_API_KEY = st.secrets["GROQ_API_KEY"]
GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions"

def load_client_config():
    """Load and validate OAuth client configuration"""
    try:
        # Try to load the client configuration file
        client_secrets_file = 'client_secrets.json'
        
        if not os.path.exists(client_secrets_file):
            st.error(f"Client configuration file '{client_secrets_file}' not found.")
            return None
            
        with open(client_secrets_file, 'r') as f:
            client_config = json.load(f)
            
        # Validate the configuration
        if 'web' not in client_config:
            st.error("Invalid client configuration: 'web' section missing")
            return None
            
        required_fields = ['client_id', 'client_secret', 'redirect_uris']
        for field in required_fields:
            if field not in client_config['web']:
                st.error(f"Invalid client configuration: '{field}' missing")
                return None
                
        return client_config
        
    except Exception as e:
        st.error(f"Error loading client configuration: {str(e)}")
        return None

def generate_ai_response(email_content, context=""):
    """Generate AI response using Groq API"""
    try:
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }
        
        prompt = f"""
        Context: {context}
        
        Email to respond to: {email_content}
        
        Generate a professional and helpful response to this email. The response should be:
        1. Professional and courteous
        2. Address all points in the original email
        3. Clear and concise
        4. Include a proper greeting and signature
        """
        
        data = {
            "model": "mixtral-8x7b-32768",
            "messages": [
                {"role": "system", "content": "You are a professional email assistant."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 1000
        }
        
        response = requests.post(GROQ_API_URL, headers=headers, json=data)
        if response.status_code == 401:
            st.error("Invalid Groq API key. Please check your API key in secrets.toml")
            return None
        response.raise_for_status()
        return response.json()['choices'][0]['message']['content']
    except requests.exceptions.RequestException as e:
        st.error(f"Error connecting to Groq API: {str(e)}")
        return None
    except Exception as e:
        st.error(f"Error generating AI response: {str(e)}")
        return None

def create_email_message(sender, to, subject, body):
    """Create email message"""
    message = MIMEText(body)
    message['to'] = to
    message['from'] = sender
    message['subject'] = subject
    raw = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
    return {'raw': raw}

def send_email(service, message):
    """Send email using Gmail API"""
    try:
        sent_message = service.users().messages().send(userId='me', body=message).execute()
        return sent_message
    except Exception as e:
        if "accessNotConfigured" in str(e):
            st.error("Gmail API is not enabled. Please enable it in the Google Cloud Console and try again in a few minutes.")
            st.markdown("[Enable Gmail API](https://console.cloud.google.com/apis/library/gmail.googleapis.com)")
        else:
            st.error(f"Error sending email: {str(e)}")
        return None

def get_redirect_uri():
    """Get the appropriate redirect URI based on the current environment"""
    return 'http://localhost:8501/'  # With trailing slash for OAuth callback

def clear_oauth_error():
    """Clear OAuth error from session state"""
    if 'oauth_error' in st.session_state:
        st.session_state.oauth_error = None

def initialize_oauth_flow():
    """Initialize OAuth flow and generate authorization URL"""
    try:
        # Load client configuration
        client_config = load_client_config()
        if not client_config:
            return None, None
            
        # Get redirect URI
        redirect_uri = get_redirect_uri()
        
        # Create flow instance
        flow = Flow.from_client_config(
            client_config,
            scopes=GMAIL_SCOPES,
            redirect_uri=redirect_uri
        )
        
        # Generate random state
        if 'oauth_state' not in st.session_state:
            st.session_state.oauth_state = base64.b64encode(os.urandom(32)).decode('utf-8')
        
        # Generate authorization URL with state
        auth_url, _ = flow.authorization_url(
            access_type='offline',
            include_granted_scopes='true',
            state=st.session_state.oauth_state
        )
        
        return flow, auth_url
        
    except Exception as e:
        st.error(f"Error initializing OAuth flow: {str(e)}")
        return None, None

def handle_oauth_callback():
    """Handle the OAuth callback and token exchange"""
    try:
        # Get the authorization code from URL parameters
        query_params = st.experimental_get_query_params()
        code = query_params.get("code", [None])[0]
        state = query_params.get("state", [None])[0]
        
        if not code:
            st.error("No authorization code received")
            return
            
        if not state or state != st.session_state.get('oauth_state'):
            st.error("Invalid state parameter")
            return
            
        # Load client configuration
        client_config = load_client_config()
        if not client_config:
            return
            
        # Create flow instance
        flow = Flow.from_client_config(
            client_config,
            scopes=GMAIL_SCOPES,
            redirect_uri=get_redirect_uri()
        )
        
        try:
            # Exchange code for token
            flow.fetch_token(code=code)
            credentials = flow.credentials
            
            # Store token in session state
            st.session_state.token = {
                'token': credentials.token,
                'refresh_token': credentials.refresh_token,
                'token_uri': credentials.token_uri,
                'client_id': credentials.client_id,
                'client_secret': credentials.client_secret,
                'scopes': credentials.scopes
            }
            st.session_state.authenticated = True
            
            # Clear the URL parameters
            st.experimental_set_query_params()
            st.success("Successfully authenticated with Gmail!")
            time.sleep(1)
            st.experimental_rerun()
            
        except Exception as e:
            st.error(f"Error exchanging code for token: {str(e)}")
            st.session_state.oauth_error = str(e)
            return
            
    except Exception as e:
        st.error(f"Error in OAuth callback: {str(e)}")
        st.session_state.oauth_error = str(e)
        return

def initialize_supabase():
    """Initialize Supabase client with error handling"""
    try:
        supabase_url = st.secrets.get("SUPABASE_URL")
        supabase_key = st.secrets.get("SUPABASE_KEY")
        
        if not supabase_url or not supabase_key:
            st.error("Supabase credentials not found in secrets.toml")
            return None
            
        client = create_client(supabase_url, supabase_key)
        
        # Create the table using raw SQL through REST API
        try:
            # First, try to select from the table to check if it exists
            client.table('knowledge_base').select('*').limit(1).execute()
            return client
        except Exception as e:
            st.info("Setting up knowledge base...")
            try:
                # Create table with SQL
                client.rpc(
                    'exec_sql',
                    {
                        'query': """
                        DROP TABLE IF EXISTS knowledge_base CASCADE;
                        CREATE TABLE knowledge_base (
                            id SERIAL PRIMARY KEY,
                            title TEXT NOT NULL,
                            content TEXT NOT NULL,
                            created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                        );
                        -- Create index for faster sorting
                        CREATE INDEX idx_knowledge_base_created_at ON knowledge_base(created_at DESC);
                        -- Grant permissions
                        GRANT ALL ON TABLE knowledge_base TO authenticated;
                        GRANT ALL ON SEQUENCE knowledge_base_id_seq TO authenticated;
                        """
                    }
                ).execute()
                
                # Wait a moment for schema to refresh
                time.sleep(2)
                st.success("Knowledge base setup complete!")
                return client
                
            except Exception as setup_error:
                st.error(f"Error setting up database: {str(setup_error)}")
                return None
                
    except Exception as e:
        st.error(f"Error initializing Supabase: {str(e)}")
        return None

# Initialize Supabase
supabase = initialize_supabase()

# Title
st.title("Gmail AI Assistant")

# Sidebar navigation
st.sidebar.title("Navigation")
page = st.sidebar.radio("Go to", ["Compose Email", "Email Templates", "Knowledge Base", "Settings"])

# Gmail Authentication
if not st.session_state.authenticated:
    st.sidebar.header("Gmail Authentication")
    if st.sidebar.button("Connect Gmail"):
        flow, auth_url = initialize_oauth_flow()
        if flow and auth_url:
            st.sidebar.markdown(f'[Click here to authorize Gmail]({auth_url})')
            st.sidebar.info("Please click the link above to connect your Gmail account")
        else:
            st.sidebar.error("Failed to initialize OAuth flow")
else:
    st.sidebar.success("✓ Connected to Gmail")
    if st.sidebar.button("Logout"):
        st.session_state.authenticated = False
        st.session_state.token = None
        clear_oauth_error()
        st.experimental_rerun()

# Handle OAuth callback if there's a code in URL
if st.experimental_get_query_params():
    handle_oauth_callback()

# Display OAuth error if present
if st.session_state.oauth_error:
    with st.sidebar:
        st.error(st.session_state.oauth_error)
        if st.button("Clear Error"):
            clear_oauth_error()
            st.experimental_rerun()

# Main content
if page == "Compose Email":
    if not st.session_state.authenticated:
        st.warning("Please connect your Gmail account first")
    else:
        st.header("Compose Email")
        
        # Email form
        col1, col2 = st.columns(2)
        with col1:
            to = st.text_input("To", key="to")
            subject = st.text_input("Subject", key="subject")
        
        # Message body
        message = st.text_area("Message", value=st.session_state.message_input, height=200, key="message_area")
        
        # Update message input in session state
        if message != st.session_state.message_input:
            st.session_state.message_input = message
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Generate AI Response"):
                with st.spinner("Generating response..."):
                    ai_response = generate_ai_response(st.session_state.message_input)
                    if ai_response:
                        st.session_state.ai_response = ai_response
                        st.success("AI response generated!")
        
        with col2:
            if st.button("Send Email") and st.session_state.authenticated:
                if not to or not subject or not message:
                    st.error("Please fill in all fields")
                else:
                    with st.spinner("Sending email..."):
                        try:
                            creds = Credentials.from_authorized_user_info(st.session_state.token)
                            service = build('gmail', 'v1', credentials=creds)
                            
                            # Get user's email address
                            user_info = service.users().getProfile(userId='me').execute()
                            sender = user_info['emailAddress']
                            
                            # Create and send message
                            email_message = create_email_message(
                                sender,
                                to,
                                subject,
                                message
                            )
                            
                            if send_email(service, email_message):
                                st.success("Email sent successfully!")
                                # Clear the form
                                st.session_state.message_input = ""
                                st.session_state.ai_response = ""
                                st.experimental_rerun()
                        except Exception as e:
                            st.error(f"Error sending email: {str(e)}")
        
        # Display AI response if available
        if st.session_state.ai_response:
            st.subheader("AI Generated Response")
            st.text_area("AI Response", value=st.session_state.ai_response, height=300, key="ai_response_display")
            if st.button("Use AI Response"):
                st.session_state.message_input = st.session_state.ai_response
                st.experimental_rerun()

elif page == "Email Templates":
    st.header("Email Templates")
    st.info("Coming soon!")

elif page == "Knowledge Base":
    st.header("Knowledge Base")
    if not supabase:
        st.error("Could not connect to knowledge base. Please check your Supabase configuration.")
    else:
        # Add new entry
        with st.expander("Add New Entry"):
            title = st.text_input("Title", key="kb_title")
            content = st.text_area("Content", key="kb_content")
            if st.button("Add Entry", key="kb_add"):
                if title and content:
                    try:
                        # Direct table insert
                        data = {
                            'title': title,
                            'content': content
                        }
                        result = supabase.table('knowledge_base').insert(data).execute()
                        
                        if result and hasattr(result, 'data'):
                            st.success("Entry added successfully!")
                            time.sleep(1)
                            st.experimental_rerun()
                    except Exception as e:
                        st.error(f"Error adding entry: {str(e)}")
                else:
                    st.warning("Please fill in both title and content")
        
        # View entries
        try:
            # Fetch entries with simple query
            result = supabase.table('knowledge_base').select('*').order('created_at', desc=True).execute()
            
            if result and hasattr(result, 'data'):
                entries = result.data
                if entries:
                    for entry in entries:
                        with st.expander(f"{entry.get('title', 'Untitled')}"):
                            st.write(entry.get('content', 'No content'))
                            created_at = entry.get('created_at')
                            if created_at:
                                st.caption(f"Created: {created_at}")
                else:
                    st.info("No entries yet. Add some knowledge to get started!")
        except Exception as e:
            st.error(f"Error fetching entries: {str(e)}")

elif page == "Settings":
    st.header("Settings")
    
    # Gmail Connection Status
    st.subheader("Gmail Connection")
    if st.session_state.authenticated:
        st.success("Gmail Connection Status: Connected")
        st.json(st.session_state.token)
    else:
        st.warning("Gmail Connection Status: Not Connected")
